;function to find the greatest of three numbers
(define (max3 x y z) (
    if (and (>= x y) (>= x z))
        x
    ;else
        (if (>= y z)
                y
            ;else
                z
        )
))

;creating a list
(define list1 '(1 2 3 4))

;list operations
(length list1)
(null? '())
(append list1 '(5))
(cons 'a list1)

;length of a list
(define (len L) (
    if (null? L)
        0
    ;else
        (+ 1 (len (cdr L)))
))

;append two lists
(define (app L1 L2) (
    if (null? L1)
        L2
    ;else
        (cons (car L1) (app (cdr L1) L2))
))

;append a value to a list
(append list1 (cons 'a '()))
(append list1 '(a . ()))

;reverse a list
(define (rev L) (
    if (null? L)
        L
    ;else
        (append (rev (cdr L)) (cons (car L) '()))
))

;count the ocurrence of an element in a list
(define (count x L) (
    if (null? L)
        0
    ;else
        (if (= (car L) x)
            (+ 1 (count x (cdr L)))
        ;else
            (count x (cdr L))
        )
))

;cond expression as opposed to if
(define (is_neg x) (
    cond((< x 0) 'yes)
        ((> x 0) 'no)
        (else 'neither)
))

;pairs
(cons 'a 'b)
'(a . (b . (c . ())))
'(((() . c) . b) . a)

;count function using cond and symbolic equality
(define (count x L) (
    cond((null? L) 0)
        ((eq? (car L) x) (+ 1 (count x (cdr L))))
        (else (count x (cdr L)))
))

;recursive count function
(define (countall x L) (
    if (null? L) 0
        (if (pair? L) (+ (countall x (car L)) (countall x (cdr L)))
            (if (eq? x L) 1 0))
))

;equal? recursive
(define (equ? L1 L2) (
    if (and (pair? L1) (pair? L2))
        (and (equ? (car L1) (car L2)) (equ? (cdr L1) (cdr L2)))
    ;else
        (eq? L1 L2)
))

;flatten
(define (flatten L) (
    if (pair? L)
        (append (flatten (car L)) (flatten (cdr L)))
    ;else
        (if (null? L) L (cons L '()))
))

;map
(map square '(1 2 3 4))

;map implementation
(define (m f L) (
  cond ((null? L) '())
  (else (cons (f (car L)) (m f (cdr L))))  
))

;first element of each sub list
(map car '((a b c) (1 2 3) (z x c)))

;filter
(filter positive? '(1 -1 2 -2 3))

;filter implementation
(define (filt x L) (
    cond ((null? L) '())
    ((f (car L)) (cons (car L) (filt x (cdr L))))
    (else (filt x (cdr L)))
))

(define (filt f L) (
    if (null? L) L
        (if (f (car L)) (cons (car L) (filt f (cdr L))))
            (filt f (cdr L))
))

;reject implementation
(define (reject f L) (if (null? L) L
    (if (f (car L)) (reject f (cdr L))
        (cons (car L) (reject f (cdr L)))
        )
    )
)

;fold
(fold-left + 0 '(1 2 3 4))
(fold-left * 1 '(1 2 3 4))
(fold-left append '() '((10 20) (a b c) (4 5)))

(define (foldl f id L) (
    if (null? L) id
        (foldl f (f id (car L)) (cdr L)) 
))

(define (foldr f id L) (
    if (null? L) id
        (f (car L) (foldr f id (cdr L)))
))

(fold-left cons '() '(1 2 3 4))
(fold-right cons '() '(1 2 3 4))

;zip
(define (z L1 L2) (
    if (or (null? L1) (null? L2)) '()
        (cons (list (car L1) (car L2)) (z (cdr L1) (cdr L2)))
))

;zipwith
(define (zipwith f L1 L2) (
    if (or (null? L1) (null? L2)) '()
        (cons (f (car L1) (car L2)) (zipwith f (cdr L1) (cdr L2)))
))

;anonymous function (lambda)
(define g (lambda (x) (+ x 3)))
(g 5)

((lambda (x) (+ x 3)) 5)
(map (lambda (x) (+ x 3)) '(1 2 3))

(define mycons (lambda (x) (lambda (y) (cons x y))))
(cons 1 2)
((mycons 1) 2)

(define ((mycons2 x) y) (cons x y))
((mycons2 1) 2)

(define (mycons3 x) (lambda (y) (cons x y)))
((mycons3 1) 2)

(map (mycons 5) '(1 2 3 4))

(fold-left (lambda (x y) (cons y x)) '() '(1 2 3 4))
(fold-right (lambda (x y) (cons y x)) '() '(1 2 3 4))
