;;;;;;;;;;;;;;;;;

;function to find the greatest of three numbers

(define (max3 x y z) (
    if (and (>= x y) (>= x z))
        x
    ;else
        (if (>= y z)
                y
            ;else
                z
        )
))

;;;;;;;;;;;;;;;;;;;

;lists

(define list1 '(1 2 3 4))

;list operations

(length list1)
(null? '())
(append list1 '(5))
(cons 'a list1)

;;;;;;;;;;;;;;;;;;;

;length implementation

(define (len L) (
    if (null? L)
        0
    ;else
        (+ 1 (len (cdr L)))
))

;;;;;;;;;;;;;;;

;append implementation

(define (app L1 L2) (
    if (null? L1)
        L2
    ;else
        (cons (car L1) (app (cdr L1) L2))
))

;append a value to a list

(append list1 (cons 'a '()))
(append list1 '(a . ()))

;;;;;;;;;;;;;;;;;;

;reverse implementation

(define (rev L) (
    if (null? L)
        L
    ;else
        (append (rev (cdr L)) (cons (car L) '()))
))

;;;;;;;;;;;;;;;

;count the ocurrence of an element in a list

(define (count x L) (
    if (null? L)
        0
    ;else
        (if (= (car L) x)
            (+ 1 (count x (cdr L)))
        ;else
            (count x (cdr L))
        )
))

;;;;;;;;;;;;;;;;;;

;cond expression as opposed to if

(define (is_neg x) (
    cond((< x 0) 'yes)
        ((> x 0) 'no)
        (else 'neither)
))

;;;;;;;;;;;;;;;;;;;

;pairs

(cons 'a 'b)
'(a . (b . (c . ())))
'(((() . c) . b) . a)

;;;;;;;;;;;;;;;;;;;

;count function using cond and symbolic equality

(define (count x L) (
    cond((null? L) 0)
        ((eq? (car L) x) (+ 1 (count x (cdr L))))
        (else (count x (cdr L)))
))

;;;;;;;;;;;;;;;;;;;;

;recursive count function

(define (countall x L) (
    if (null? L) 0
        (if (pair? L) (+ (countall x (car L)) (countall x (cdr L)))
            (if (eq? x L) 1 0))
))

;;;;;;;;;;;;;;;;;;;;

;equal? recursive

(define (equ? L1 L2) (
    if (and (pair? L1) (pair? L2))
        (and (equ? (car L1) (car L2)) (equ? (cdr L1) (cdr L2)))
    ;else
        (eq? L1 L2)
))

;;;;;;;;;;;;;;;;;;;;;;;

;flatten

(define (flatten L) (
    if (pair? L)
        (append (flatten (car L)) (flatten (cdr L)))
    ;else
        (if (null? L) L (cons L '()))
))

;;;;;;;;;;;;;;;;;;;;

;map

(map square '(1 2 3 4))

;map implementation

(define (m f L) (
  cond ((null? L) '())
  (else (cons (f (car L)) (m f (cdr L))))  
))

;first element of each sub list

(map car '((a b c) (1 2 3) (z x c)))

;;;;;;;;;;;;;;;;;;;;

;filter

(filter positive? '(1 -1 2 -2 3))

;filter implementation

(define (filt f L) (
    cond ((null? L) '())
    ((f (car L)) (cons (car L) (filt f (cdr L))))
    (else (filt f (cdr L)))
))
(filt positive? '(1 -1 2 -2 3))

;;;;;;;;;;;;;;;;;

;reject implementation

(define (reject f L) (if (null? L) L
    (if (f (car L)) (reject f (cdr L))
        (cons (car L) (reject f (cdr L)))
        )
    )
)
(reject positive? '(1 -1 2 -2 3))

;;;;;;;;;;;;;;;;;

;fold

(fold-left + 0 '(1 2 3 4))
(fold-left * 1 '(1 2 3 4))
(fold-left append '() '((10 20) (a b c) (4 5)))

(define (foldl f id L) (
    if (null? L) id
        (foldl f (f id (car L)) (cdr L)) 
))
(foldl + 0 '(1 2 3 4))

(define (foldr f id L) (
    if (null? L) id
        (f (car L) (foldr f id (cdr L)))
))
(foldr - 0 '(1 2 3 4)) ;equals ((((4-0)-3)-2)-1)

(fold-left cons '() '(1 2 3 4))
(fold-right cons '() '(1 2 3 4))

;;;;;;;;;;;;;;;;;;;;;;

;zip

(zip '(1 2 3) '(1 2 3))
(define (z L1 L2) (
    if (or (null? L1) (null? L2)) '()
        (cons (list (car L1) (car L2)) (z (cdr L1) (cdr L2)))
))
(z '(1 2 3) '(1 2 3))

;zipwith

(define (zipwith f L1 L2) (
    if (or (null? L1) (null? L2)) '()
        (cons (f (car L1) (car L2)) (zipwith f (cdr L1) (cdr L2)))
))
(zipwith + '(1 2 3) '(1 2 3))

;;;;;;;;;;;;;;;;;;;;

;anonymous functions (lambda)

(define g (lambda (x) (+ x 3)))
(g 5)

((lambda (x) (+ x 3)) 5)

(map (lambda (x) (+ x 3)) '(1 2 3))

;;;;;;;;;;;;;;;;;;

;cons using lambda  (3 implementations)

(define mycons (lambda (x) (lambda (y) (cons x y))))
(cons 1 2)
((mycons 1) 2)

(define ((mycons2 x) y) (cons x y))
((mycons2 1) 2)

(define (mycons3 x) (lambda (y) (cons x y)))
((mycons3 1) 2)

(map (mycons 5) '(1 2 3 4))

;;;;;;;;;;;;;;;;;;;;;;;

;fold using lambda

(fold-left (lambda (x y) (cons y x)) '() '(1 2 3 4))
(fold-right (lambda (x y) (cons y x)) '() '(1 2 3 4))

;;;;;;;;;;;;;;;;;;;;;;;;;

;trees

; a
; |       \       \
; b       c        d
; |\      |        |
; e f     g      h j k
;         |\       |
;         m n      p

;(root subtree1, subtree2, ...)

(define tree1 '(a (b(e)(f)) (c (g(m)(n))) (d (h)(j(p))(k))))

;post order

;(efb) (mngc) (hpjkd) (a)

(define (postorder T) (
    if (null? T) '()
        (fold-right append (list (car T)) (map postorder (cdr T)))
))
(postorder tree1)

;;;;;;;;;;;;;;;;;;;;;

;fibonacci

(define (fib1 n) (
    if (< n 2) n
        (+ (fib1 (- n 1)) (fib1 (- n 2)))
))

(define (help n a b) (
    if (= n 0) a
        (help (- n 1) b (+ a b))
))

(define (fib2 n) (
    (help n 0 1)
))

(define (help2 n) (
    if (= n 0) '(0 . 1)
        (let ((p (help2 (- n 1))))
            (cons (cdr p) (+ (car p) (cdr p)))
        )
))

(define (fib3 n) (
    (car (help2 n))  
))